# -*- coding: utf-8 -*-
"""Sem_3_02_24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q7fplMDJ0WmGAftT3JT2dwmsBArrMWKT

#Базы данных

80-е годы реляционные базы данных

90-е годы объекто-ориентированные базы данных

**основные термины:**

БД, СУБД

модели, реляционная модель: сущности и связи

таблицы, кортеж, реляционная логика, связный граф, вершины-сущности (таблицы/отношения), ребра-связи (столбцы/признаки с совпадающими доменами)

за одну бд отвечает один связный граф

ключ (primary key)

[тут](https://cs.mipt.ru/advanced_python/lessons/lab19.html#argparse/) ссылка на лабу

##Реляционные бд

Данные в реляционной базе организованы в виде таблиц, состоящих из столбцов и строк. Реляционная СУБД обеспечивает быстрый и эффективный доступ к структурированной информации.

Что такое "реляционный"?

Построенный по принципам реляционной логики.

Что это значит?

Значит, что есть три значения: true, false, idk

*   много кортежей -> таблица
*   много таблиц -> база данных

БД -- связный граф


*  Вершины -- сущности (таблицы/отношения)
*  Ребра -- связи (столбцы/признаки с совпадающими значениями атрибутов)

**ключ (primary key)**

используется для однозначной идентификации каждого кортежа в таблице

##SQL: теория

-- язык структурированных запросов

для обращения к БД нам понадобится клиентская часть СУБД. Для этих целей используется компактно встраиваемая СУБД SQLite.

Мы будем пользоваться утилитой командной строки sqlite3.

Для работы с базой данных запустите утилиту, указав имя файла БД. Если файл не существует, то он будет создан.
"""

sqlite3 test.db

"""Запустив утилиту, вы попадете в интерактивный режим. Все команды утилиты начинаются с точки. Ознакомиться со списком команд можно при помощи .help


"""

sqlite> .help

"""Для завершения работы с утилитой введите .quit или сочетание клавиш ctrl+D. Интерактивный режим утилиты позволяет как напрямую писать запросы на языке SQL, так и запускать на исполнение sql файлы. Для запуска файла используется команда .read path/to/sql/file. Для удобства используйте команды




"""

sqlite> .mode column
sqlite> .headers on

"""Это позволит отображать результаты запросов в виде выравненных таблиц с названиями столбцов.

**Синтаксис SQL**



*   не регистрозависимый, но есть нюанс
заглавные: ключевые слова и функции
строчные: названия таблиц и атрибутов
*   Комментарии:

1: --

2:  /* */

*   все выражения начинаются с ключевого слова и оканчиваются ;

**Типы данных**



*   NULL – пустое значение;
*   INTEGER – 1, 2, 3, 4, 6 или 8 байтное знаковое число;
*   REAL – 8-байтное число с плавающей запятой;
*   TEXT – строка в кодировке UTF-8, UTF-16BE или UTF-16LE (зависит от базы данных);
*   BLOB – массив двоичных данных, обычно нужен для хранения мультимедийных объектов и скомпилированного программного кода.
*   BOOLEAN в SQLite представлен типом INTEGER со значениями 0 и 1.
*   Под дату/время нет специального типа. Для хранения даты/времени используют текстовый формат: YYYY-MM-DD HH:MM:SS.SSS

Для того, чтобы получить текущее время в этом представлении, можно использовать функцию DATETIME("now"). Полученный результат будет отображать текущее время по UTC (Coordinated Universal Time). Московское время – UTC+3. Если необходимо получить локальное текущее время, то DATETIME("now", "localtime").


REAL хранит время в виде юлианской даты, т.е. количество суток, прошедших с полудня 24 ноября 4714 г. до н.э. по григорианскому календарю. Дробная часть показывает время. Например, 2451545,25 есть 18 часов 1 января 2000 года. Т.к. такой формат не особо читаемый, то функции DATE и TIME от такого дробного числа возвращают дату и время соответственно.

INTEGER работает с широко известным UNIX timestamp. Timestamp показывает количество секунд, прошедших с 00:00:00 по UTC 1 января 1970 года (этот момент времени – UNIX epoch). Чтобы получить время в этом представлении, воспользуйтесь STRFTIME("%s", "now"). Функция поддерживает и модификатор localtime. Для перевода в читаемый формат используйте: DATETIME(timestamp, "unixepoch").

##SQL: практика

### Создание, удаление и изменение таблиц

**CREATE TABLE**

Для создания таблицы используется команда CREATE TABLE. Общий синтаксис команды:


CREATE TABLE table_name(

    column1 datatype PRIMARY KEY,
    column2 datatype,

    column3 datatype,
    .....
    columnN datatype
);


Обратите внимание, что в таблице хотя бы один атрибут должен быть ключом. Рассмотрим несколько примеров

создадим пример таблицы:

CREATE TABLE company(

    id INT,
    name TEXT,
    age INT,
    address TEXT,
    salary REAL
);

CREATE TABLE department(

    id INT,
    dept TEXT,
    emp_id INT
);

и удалим ее сразу:

DROP TABLE company;

теперь посмотрим на то, какие параметры можно навесить на таблицу и её атрибуты:



*   NOT NULL указывает на то, что атрибут не может иметь пустое значение;
*   DEFAULT позволяет задать атрибуту значение по умолчанию;
*   UNIQUE делает значения атрибутов уникальным для каждой строки;
*   PRIMARY KEY однозначно определяет каждую строку (может быть указан только у одного атрибута);
*   FOREIGN KEY связывает столбец одной таблицы со столбцом другой таблицы;
*   AUTOINCREMENT автоматически задает атриубуту увеличивающееся значение;
*   CHECK проверяет, что значения атрибута удовлетворяют логическому выражению.

модифицируем таблицы:

CREATE TABLE company(

    id INT PRIMARY KEY NOT NULL,
    name TEXT NOT NULL,
    age INT NOT NULL,
    address TEXT,
    salary REAL DEFAULT 30000 CHECK(salary >= 0)
);

CREATE TABLE department(

    id INT PRIMARY KEY NOT NULL,
    dept TEXT NOT NULL,
    emp_id INT NOT NULL,
    FOREIGN KEY (emp_id) REFERENCES company (id)
);

Заметьте, что теперь department.emp_id и company.id связаны, и department.emp_id может содержать только те значения, что есть в company.id.



**А как менять таблицы?**

**ALTER TABLE**

Для изменения таблицы есть команда ALTER TABLE. В SQLite поддерживается 2 варианта: переименование таблицы и добавление столбца.

ALTER TABLE old_table RENAME TO new_table;

ALTER TABLE table_name ADD COLUMN column_definition;

Добавленный столбец не может быть UNIQUE или PRIMARY KEY. Если он NOT NULL, то обязательно должны быть указаны значения по умолчанию.

### Добавление строк

**INSERT**

INSERT INTO table_name (column1, column2, ...)

VALUES

    (value1, value2, ...),
    ...
    (value1, value2, ...);


пример:

INSERT INTO company

VALUES

    (1, 'Paul', 32, 'California', 20000.00),
    (2, 'Allen', 25, 'Texas', 15000.00),
    (3, 'Teddy', 23, 'Norway', 20000.00),
    (4, 'Mark', 25, 'Rich-Mond ', 65000.00),
    (5, 'David', 27, 'Texas', 85000.00),
    (6, 'Kim', 22, 'South-Hall', 45000.00),
    (7, 'James', 24, 'Houston', 10000.00);

INSERT INTO department

VALUES

    (1, 'IT Billing', 1),
    (2, 'Engineering', 6),
    (3, 'Finance', 5),
    (4, 'HR', 5);

### **SELECT**

Запрос SELECT позволяет получить выборку данных из одной или нескольких таблиц. Кроме того SELECT можно использовать для вычислений.

SELECT 1 + 1;

SELECT 10 / 5, 2 * 4;

Обычно запрос используется для получения данных из таблицы. Общий вид запроса следующий:



> SELECT DISTINCT column_list
FROM table_list
JOIN table_name ON join_condition
WHERE search_condition
ORDER BY column_list
LIMIT count
OFFSET offset
GROUP BY column_name
HAVING group_filter;




**SELECT name, salary FROM company;**

Такой запрос создаст временную таблицу из столбцов company.name и company.salary, заполнив ее значениями из таблицы company. Если нам необходимо просмотреть данные всех столбцов, то список столбцов заменяется на *.


SELECT * FROM company;

### **ORDER BY**

сортировка данных

SELECT name, age, salary
FROM company
ORDER BY

    age ASC,
    salary DESC;

  
ASC и DES означают сортировку по возрастанию и убыванию соответственно.

### DISTINCT

DISTINCT убирает дублирующиеся строки. Сравните результаты двух запросов.

SELECT age FROM company;

SELECT DISTINCT age FROM company;

### WHERE

WHERE позволяет отфильтровать результаты путем вычисления логических выражений, объединенных логическими AND и OR. Примеры фильтров:

... WHERE column1 = 100;

... WHERE column2 NOT IN (1, 2, 3);

... WHERE column3 IS NULL;

... WHERE column4 BETWEEN 10 AND 20;


WHERE поддерживает еще пару выражений, которые мы пока опустим.

### LIMIT and OFFSET

LIMIT позволяет ограничить количество строк в результате. Например, после сортировки работников по атрибуту salary мы бы хотели видеть только топ 10 зарплат в компании. OFFSET позволяет сдвинуть начало отсчета. Например,

LIMIT 10 OFFSET 5;

позволит посмотреть следующие топ 10 зарплат после топ 5.

### GROUP BY

выполняет группировку данных по указанным столбцам. При использовании группировки обычно подсчитывают ту или иную статистику внутри каждой группы. Например, MAX, MIN, COUNT, AVG.

SELECT emp_id, COUNT(id)
FROM department
GROUP BY emp_id;

### HAVING

Первый столбец будет содержать id работников, а второй столбец — количество отделов,в которых он работает. HAVING позволяет фильтровать результаты GROUP BY. Например

SELECT emp_id, COUNT(id)
FROM department
GROUP BY emp_id
HAVING COUNT(id) = 1;
оставит только тех сотрудников, которые работают только в одном отделе.

### JOIN

#### CROSS JOIN

декартово произведение

SELECT *
FROM company, department;

SELECT *
FROM company
CROSS JOIN department;
Приведенные два запроса эквивалентны, но лучше использовать второй, т.к. он явно указывает тип объединения.


#### INNER JOIN

Он строит результат только из тех пар строк, которые удовлетворяют предикату, среди всех возможных пар.

SELECT name, dept
FROM company
INNER JOIN department

    ON company.id = department.emp_id;


#### LEFT JOIN

LEFT JOIN для каждой строки из первой таблицы выбирает все подходящие строки из второй. Если таковой не существует, парой к строке из первой таблицы берется пустая строка.

SELECT name, dept
FROM company
LEFT JOIN department

    ON company.id = department.emp_id;

Как можно увидеть, в столбце name теперь есть все сотрудники. Однако столбец dept заполнен только у тех сотрудников, про которых есть информация в department.

#### DELETE

удаляем так строки.

DELETE FROM table_name
WHERE search_condition;

#### UPDATE

Изменение данных в уже существущих строках выполняется при помощи UPDATE. Его вид:

UPDATE table_name
SET

    column1 = value1,
    column2 = value2,
    ...

WHERE search_condition
ORDER BY column_or_expression
LIMIT row_count OFFSET offset;

ORDER BY и LIMIT выполняют те же роли, что и в SELECT запросе.

**источник:**

1. [про разные типы БД текстик](https://www.oracle.com/cis/database/what-is-database/)
2. ...
"""

